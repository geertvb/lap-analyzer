<?xml version="1.0" encoding="utf-8"?>
<s:VGroup
	xmlns:fx="http://ns.adobe.com/mxml/2009" 
	xmlns:s="library://ns.adobe.com/flex/spark" 
	xmlns:mx="library://ns.adobe.com/flex/halo" 
	xmlns:net="flash.net.*"
	creationComplete="creationComplete()"
	xmlns:trackservice="services.trackservice.*" 
	xmlns:intersectionservice="services.intersectionservice.*" 
	xmlns:gpslogservice="services.gpslogservice.*">
	
	<fx:Script>
		<![CDATA[
			import valueObjects.Intersection;
			import mx.controls.Label;
			import mx.core.UITextField;
			import mx.binding.utils.BindingUtils;
			import mx.controls.Text;
			import util.IntersectionUtils;
			import mx.core.UIComponent;
			import mx.core.FlexSprite;
			import com.google.maps.LatLng;
			import mx.utils.ArrayUtil;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.AsyncToken;
			import mx.collections.ArrayCollection;
			import mx.rpc.events.ResultEvent;
			import mx.events.FlexEvent;
			import mx.utils.StringUtil;
			import mx.controls.Alert;
			import mx.messaging.AbstractConsumer;
			import __AS3__.vec.Vector;
			
			public var min_lat: Number;
			public var max_lat: Number;
			public var min_lng: Number;
			public var max_lng: Number;

			public var minX: Number;
			public var maxX: Number;
			public var minY: Number;
			public var maxY: Number;
			public var dX: Number;
			public var dY: Number;
			public var d: Number;
			
			[Bindable] 
			private var commands: Vector.<int> = new Vector.<int>();

			[Bindable] 
			private var thedata: Vector.<Number> = new Vector.<Number>();
			
			[Bindable]
			private var intersections: ArrayCollection;
			
			public function creationComplete() : void {
				findSampleTrackData.token = gpslogService.findSampleTrackData(1);
				dataGrid_refresh();
			}
			
			public function dataReady(s: String) : void {
				var lines: Array = s.split("\n");
				var i: uint;
				
				var headings: Array = lines[0].split(",");
				//INDEX,RCR,DATE,TIME,VALID,LATITUDE,N/S,LONGITUDE,E/W,HEIGHT,SPEED,DISTANCE,
				var latIndex: uint = headings.indexOf("LATITUDE");
				var lngIndex: uint = headings.indexOf("LONGITUDE");
				var spdIndex: uint = headings.indexOf("SPEED");
				var timeIndex: uint = headings.indexOf("TIME");
				
				minX = Number.MAX_VALUE;
				maxX = Number.MIN_VALUE;
				minY = Number.MAX_VALUE;
				maxY = Number.MIN_VALUE;
				
				var points: Array = new Array();
				for (i = 1; i<lines.length; i++) {
					var line: String = lines[i];
					var values: Array = line.split(",");
					if (values.length >= 2) {
						var lat: Number = values[latIndex];
						var lng: Number = values[lngIndex];
						
						min_lat = Math.min(min_lat, lat);
						max_lat = Math.max(max_lat, lat);
						min_lng = Math.min(min_lng, lng);
						max_lng = Math.max(max_lng, lng);
						
						var p: Point = GeoFlatten.convert(lat, lng);
						
						minX = Math.min(minX, p.x);
						maxX = Math.max(maxX, p.x);
						minY = Math.min(minY, p.y);
						maxY = Math.max(maxY, p.y);
						
						//var point: Point = new Point(lat, lng);
						points.push(p);
					}
				}
				dX = maxX - minX;
				dY = maxY - minY;
				d = Math.max(dX, dY);
				
				thedata = new Vector.<Number>();
				for each (var point: Point in points) {
					thedata.push((point.x - minX) * 400 / d);
					thedata.push((maxY - point.y) * 400 / d);
				}
				//Alert.show(minLat + " " + maxLat + " " + minLng + " " + maxLng);

				commands = new Vector.<int>();
				commands.push(GraphicsPathCommand.MOVE_TO);
				for (i = 2; i < thedata.length; i += 2) {
					commands.push(GraphicsPathCommand.LINE_TO);
				}
				
				drawTrack();
			}
			
			public function drawTrack() :void {
				c1.removeAllChildren();
				c1.graphics.clear();
				c1.graphics.lineStyle(1,0,1);
				c1.graphics.drawPath(commands, thedata);
			}

			public function findNearest(event: MouseEvent) : void {
				var min: Number = Number.MAX_VALUE;
				var best: int = -1;
				
				for (var i:uint = 2; i < thedata.length-2; i += 2) {
					var cd: Number = (thedata[i] - event.localX) * (thedata[i] - event.localX)
						+ (thedata[i+1] - event.localY) * (thedata[i+1] - event.localY);
					if (cd < min) {
						min = cd;
						best = i;
					}
				}
				
				if (min <= 100) {
				
					var vx: Number = thedata[best+2] - thedata[best-2];
					var vy: Number = thedata[best+3] - thedata[best-1];
					
					var vd: Number = Math.sqrt(vx * vx + vy * vy);
					vx = vx / vd * 10;
					vy = vy / vd * 10;
					
					var x1: Number = thedata[best] - vy;
					var y1: Number = thedata[best+1] + vx;
					
					var x2: Number = thedata[best] + vy;
					var y2: Number = thedata[best+1] - vx;
					
					var sprite: UIComponent = new UIComponent();
					c1.addChild(sprite);
	
					sprite.graphics.lineStyle(2,0xFF0000,1);
					sprite.graphics.drawPath(
						Vector.<int>([GraphicsPathCommand.MOVE_TO,GraphicsPathCommand.LINE_TO]),
						Vector.<Number>([x1,y1,x2,y2])
					);
					sprite.graphics.drawCircle(x1, y1, 4);
					sprite.graphics.drawCircle(x2, y2, 4);
					var tf: Label = new Label();
					//tf.text = "" + intersections.length;
					
					tf.x = thedata[best] + 2.2 * vy - 5;
					tf.y = thedata[best+1] - 2.2 * vx - 10;
					c1.addChild(tf);
					
					var x: Number = thedata[best] * d / 400 + minX;
					var y: Number = maxY - thedata[best+1] * d / 400;
					
					var latLng: LatLng = GeoFlatten.convertBack(x, y);
					var item: Object = {
						intersection_id: 0,
						track_id: 1,
						index: intersections.length,
						lat: latLngFormatter.format(latLng.lat()),
						lng: latLngFormatter.format(latLng.lng()),
						angle: Math.round(Math.atan2(vy, vx) * 180.0 / Math.PI),
						sprite: sprite,
						tf: tf,
						x: thedata[best],
						y: thedata[best+1],
						vx: vx,
						vy: vy,
						p1: new Point(x1, y1),
						p2: new Point(x2, y2)
					};
					//BindingUtils.bindProperty(tf, "text", item, "index");
					intersections.addItem(item);
					intersections.refresh();
					//dataGrid.dataProvider = intersections;
					//Alert.show("" + intersections.length);
					
				}
			}
			
			public function scan() : void {
				var s1: ArrayCollection = new ArrayCollection();
				for (var i:uint = 0; s1.length < intersections.length && i < thedata.length-2; i += 2) {
					var index: int = 0;
					for each (var intersection: Object in intersections) {
						var pt1: Point = new Point(thedata[i], thedata[i+1]);
						var pt2: Point = new Point(thedata[i+2], thedata[i+3]);
						if (IntersectionUtils.intersects(pt1, pt2, intersection.p2, intersection.p1)) {
							if (!s1.contains(intersection)) {
								s1.addItem(intersection);
							}
							trace("Intersection " + index + " " + i);
						}
						index++;
					}
				}
				for (i = 0; i < s1.length; i++) {
					var item: Object = s1.getItemAt(i);
					item.index = i;
					item.tf.text = "" + i;
					var tlm: TextLineMetrics = item.tf.measureText(item.tf.text);
					item.tf.x = item.x + 2.4 * item.vy - (tlm.width + 5) / 2;
					item.tf.y = item.y - 2.4 * item.vx - (tlm.height + 4) / 2;
				}
				intersections = s1;
			}
			
			public function click_remove() : void {
				var intersection: Object = dataGrid.selectedItem;
				c1.removeChild(intersection.sprite);
				c1.removeChild(intersection.tf);
				var index: int = intersections.getItemIndex(intersection);
				intersections.removeItemAt(index);
			}

			protected function cb_tracks_creationCompleteHandler(event:FlexEvent):void {
				findAllResult.token = trackService.findAll();
			}
			
			public function fault(event : FaultEvent) : void {
				Alert.show("fault " + event.fault);
			}
			
			public function result_findByTrack(event : ResultEvent) : void {
				intersections = ArrayCollection(event.result);
			}
			
			protected function dataGrid_refresh():void {
				if (cb_tracks.selectedItem != null) {
					var track_id: int = cb_tracks.selectedItem.track_id;
					intersectionService.findByTrack(track_id).addResponder(new mx.rpc.Responder(
						result_findByTrack, fault));
					findSampleTrackData.token = gpslogService.findSampleTrackData(track_id);
				} else {
					dataGrid.dataProvider = new ArrayCollection();
					c1.graphics.clear();
				}
			}
			
			protected function click_save() : void {
				var track_id: int = cb_tracks.selectedItem.track_id;
				var ic: ArrayCollection = new ArrayCollection();
				for each (var intersection: Object in intersections) {
					var item: Intersection = new Intersection();
					item.lat = intersection.lat;
					item.lng = intersection.lng;
					item.angle = intersection.angle;
					ic.addItem(item);
				}
				intersectionService.updateByTrack(track_id, ic);
			}

		]]>
	</fx:Script>
	
	<fx:Declarations>
		<s:CallResponder 
			id="findAllResult" 
			result="cb_tracks.selectedIndex = 0"/>
		<trackservice:TrackService 
			id="trackService" 
			fault="Alert.show(event.fault.faultString + '\n' + event.fault.faultDetail)" 
			showBusyCursor="true"/>
		<intersectionservice:IntersectionService 
			id="intersectionService" 
			fault="Alert.show(event.fault.faultString + '\n' + event.fault.faultDetail)" 
			showBusyCursor="true"/>
		<s:CallResponder 
			id="findSampleTrackData" 
			result="dataReady(String(event.result))"/>
		<gpslogservice:GpslogService
			id="gpslogService" 
			fault="Alert.show(event.fault.faultString + '\n' + event.fault.faultDetail)" 
			showBusyCursor="true"/>
		<mx:RadioButtonGroup id="startFinishGroup" />
		<mx:NumberFormatter id="latLngFormatter" precision="6" />
	</fx:Declarations>
	
	<mx:Form>
		<mx:FormItem label="Track">
			<s:DropDownList
				id="cb_tracks" 
				width="160"
				creationComplete="cb_tracks_creationCompleteHandler(event)" 
				dataProvider="{findAllResult.lastResult}"
				change="dataGrid_refresh()"
				labelField="name"/>
		</mx:FormItem>
	</mx:Form>
	
	<mx:DataGrid 
		id="dataGrid" 
		creationComplete="dataGrid_refresh()" 
		dataProvider="{intersections}">
		<mx:columns>
			<mx:DataGridColumn headerText="intersection_id" dataField="intersection_id" visible="false"/>
			<mx:DataGridColumn headerText="Index" dataField="index" width="44"/>
			<mx:DataGridColumn headerText="Latitude" dataField="lat" width="80"/>
			<mx:DataGridColumn headerText="Longitude" dataField="lng" width="80"/>
			<mx:DataGridColumn headerText="Angle" dataField="angle" width="44"/>
			<mx:DataGridColumn headerText="track_id" dataField="track_id" visible="false"/>
		</mx:columns>
		
	</mx:DataGrid>
	
	<s:HGroup>
		<s:Button 
			label="Remove"
			enabled="{dataGrid.selectedIndex >= 0}"
			click="click_remove()"/>
		<s:Button 
			label="Scan"
			click="scan()"/>
		<s:Button 
			label="Save"
			click="click_save()"/>
	</s:HGroup>
	
	<mx:Canvas 
		width="800" height="800" 
		id="c1" 
		mouseUp="findNearest(event);">
	</mx:Canvas>
	
	
</s:VGroup>
